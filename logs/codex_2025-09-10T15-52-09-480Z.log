Executing: codex exec --dangerously-bypass-approvals-and-sandbox Create and write TypeScript files for multi-agent coordination utility.

Project Context: EUFM (European Union Funds Manager) - AI Agent Orchestration System
Working Directory: /Users/panda/Desktop/UBOS
Project Type: TypeScript/Node.js multi-agent coordination system
Note: Follow the BaseAgent pattern in src/agents/ and register in AgentFactory

Safety Guidelines:
- Preserve existing functionality when modifying files
- Follow TypeScript best practices and existing code patterns
- Add proper error handling and logging
- Test changes before completing
Working Directory: /Users/panda/Desktop/UBOS
Timeout: 600000 ms

[2025-09-10T15:52:09] OpenAI Codex v0.30.0 (research preview)
--------
workdir: /Users/panda/Desktop/UBOS
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-10T15:52:09] User instructions:
Create and write TypeScript files for multi-agent coordination utility.

Project Context: EUFM (European Union Funds Manager) - AI Agent Orchestration System
Working Directory: /Users/panda/Desktop/UBOS
Project Type: TypeScript/Node.js multi-agent coordination system
Note: Follow the BaseAgent pattern in src/agents/ and register in AgentFactory

Safety Guidelines:
- Preserve existing functionality when modifying files
- Follow TypeScript best practices and existing code patterns
- Add proper error handling and logging
- Test changes before completing

[2025-09-10T15:52:12] thinking

**Working on TypeScript project**

I need to focus on a project located in the UBOS folder on my desktop. The task involves creating and writing TypeScript files for a multi-agent coordination utility. I'll follow the BaseAgent pattern found in the agents subdirectory and ensure I register everything in AgentFactory. It’s also important to provide tests. Luckily, I have full access to the necessary resources, so let’s dive into the repo!
[2025-09-10T15:52:14] codex

I’m going to scan the repository to understand the agents pattern, then add a coordination utility, update the AgentFactory, and write tests.
[2025-09-10T15:52:17] exec bash -lc 'ls -la' in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:17] bash -lc 'ls -la' succeeded in 20ms:
total 1560
drwxr-xr-x   47 panda  staff    1504 Sep 10 16:15 .
drwx------+  17 panda  staff     544 Sep 10 13:39 ..
-rw-r--r--@   1 panda  staff   14340 Sep 10 13:36 .DS_Store
drwxr-xr-x    3 panda  staff      96 Sep 10 16:21 .claude
drwxr-xr-x    3 panda  staff      96 Sep  8 16:46 .cursor
-rw-r--r--    1 panda  staff     798 Sep  8 13:28 .env
-rw-r--r--    1 panda  staff     196 Sep  7 21:10 .env.example
drwxr-xr-x   17 panda  staff     544 Sep 10 16:31 .git
-rw-r--r--    1 panda  staff      45 Sep 10 16:15 .gitattributes
drwxr-xr-x    5 panda  staff     160 Sep 10 16:16 .github
-rw-r--r--    1 panda  staff      71 Sep  8 15:04 .gitignore
drwxr-xr-x    3 panda  staff      96 Sep  9 16:53 .vscode
-rw-r--r--    1 panda  staff    5088 Sep 10 14:05 CODE_OF_CONDUCT.md
-rw-r--r--@   1 panda  staff     458 Sep 10 14:05 CONTRIBUTING.md
drwxr-xr-x    7 panda  staff     224 Sep  7 18:05 PROJECTS
-rw-r--r--@   1 panda  staff     348 Sep 10 14:07 README.md
-rw-r--r--@   1 panda  staff     425 Sep 10 14:05 SECURITY.md
drwxr-xr-x    3 panda  staff      96 Sep  6 18:05 _external
-rw-r--r--    1 panda  staff    7307 Sep  8 18:24 codex_comprehensive_dashboard_analysis.txt
[2025-09-10T15:52:17] tokens used: 430
[2025-09-10T15:52:20] exec bash -lc 'ls -la src && rg -n "class BaseAgent|AgentFactory|agents" -S src || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:20] bash -lc 'ls -la src && rg -n "class BaseAgent|AgentFactory|agents" -S src || true' succeeded in 45ms:
total 16
drwxr-xr-x  21 panda  staff   672 Sep 10 18:50 .
drwxr-xr-x  47 panda  staff  1504 Sep 10 16:15 ..
-rw-r--r--@  1 panda  staff  6148 Sep  3 12:43 .DS_Store
drwxr-xr-x   6 panda  staff   192 Sep  9 10:48 adapters
drwxr-xr-x  20 panda  staff   640 Sep 10 15:13 agents
drwxr-xr-x   3 panda  staff    96 Sep 10 18:50 aggregation
drwxr-xr-x   7 panda  staff   224 Sep  3 15:12 analytics
drwxr-xr-x   3 panda  staff    96 Sep  9 17:40 api
drwxr-xr-x   4 panda  staff   128 Sep 10 18:51 cli
drwxr-xr-x   8 panda  staff   256 Sep 10 15:13 dashboard
drwxr-xr-x   3 panda  staff    96 Sep  8 13:14 integrations
drwxr-xr-x   4 panda  staff   128 Sep  3 15:34 intelligence
drwxr-xr-x   4 panda  staff   128 Sep 10 15:13 masterControl
drwxr-xr-x   6 panda  staff   192 Sep  6 21:37 mcc
drwxr-xr-x   4 panda  staff   128 Sep  3 14:48 memory
drwxr-xr-x   4 panda  staff   128 Sep 10 18:50 messaging
drwxr-xr-x   9 panda  staff   288 Sep  9 10:47 orchestrator
drwxr-xr-x   3 panda  staff    96 Sep 10 18:50 protocols
drwxr-xr-x   6 panda  staff   192 Sep  8 17:09 tests
[2025-09-10T15:52:20] tokens used: 1540
[2025-09-10T15:52:24] exec bash -lc "ls -la src/agents && sed -n '1,200p' src/orchestrator/agentFactory.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:24] bash -lc "ls -la src/agents && sed -n '1,200p' src/orchestrator/agentFactory.ts" succeeded in 31ms:
total 328
drwxr-xr-x  20 panda  staff    640 Sep 10 15:13 .
drwxr-xr-x  21 panda  staff    672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff   1069 Sep  3 15:33 abacusAgent.ts
-rw-r--r--   1 panda  staff  16479 Sep  6 20:53 agentSummoner.ts
-rw-r--r--   1 panda  staff  11263 Sep  8 14:52 agentSummonerAgent.ts
-rw-r--r--   1 panda  staff    516 Sep  3 15:32 baseAgent.ts
-rw-r--r--   1 panda  staff   1089 Sep  3 15:33 browserAgent.ts
-rw-r--r--   1 panda  staff   1921 Sep  5 16:32 codexAgent.ts
-rw-r--r--   1 panda  staff   9194 Sep 10 14:04 codexCLIAgent.ts
-rw-r--r--   1 panda  staff  12900 Sep  8 14:52 enhancedAbacusAgent.ts
-rw-r--r--   1 panda  staff   7806 Sep  6 21:12 euFundingProposalAgent.ts
-rw-r--r--   1 panda  staff  17459 Sep 10 15:13 eufmAgentSummoner.ts
-rw-r--r--   1 panda  staff   7544 Sep 10 15:15 figmaMCPAgent.ts
-rw-r--r--   1 panda  staff   1230 Sep  5 16:32 julesAgent.ts
-rw-r--r--   1 panda  staff   1175 Sep  3 15:33 memoryAgent.ts
-rw-r--r--   1 panda  staff   6358 Sep 10 15:16 notionSyncAgent.ts
-rw-r--r--   1 panda  staff  10636 Sep 10 15:13 oradeaBusinessAgent.ts
-rw-r--r--   1 panda  staff    844 Sep  8 14:53 smokeTestAgent.ts
-rw-r--r--   1 panda  staff  12541 Sep 10 15:14 specKitCodexAgent.ts
[2025-09-10T15:52:24] tokens used: 2775
[2025-09-10T15:52:41] exec bash -lc "sed -n '1,200p' src/agents/baseAgent.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:41] bash -lc "sed -n '1,200p' src/agents/baseAgent.ts" succeeded in 349ms:
import { AgentResult } from '../orchestrator/types.js';

export interface AgentContext {
  workingDir?: string;
  shared?: Record<string, any>;
}

export interface AgentRunOptions {
  input: string;
  timeoutMs?: number;
  dryRun?: boolean;
}

export abstract class BaseAgent {
  constructor(public id: string, public requirementId: string) {}

  abstract get type(): string;
  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;

  protected now() { return new Date().toISOString(); }
[2025-09-10T15:52:41] tokens used: 1383
[2025-09-10T15:52:43] exec bash -lc "sed -n '1,220p' src/orchestrator/types.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:43] bash -lc "sed -n '1,220p' src/orchestrator/types.ts" succeeded in 36ms:
export type Capability =
  | 'coding'
  | 'research'
  | 'data'
  | 'web_automation'
  | 'memory'
  | 'file_operations'
  | 'system_access'
  | 'agent_discovery'
  | 'meta_analysis';

export interface TaskRequirement {
  id: string;
  description: string;
  capabilities: Capability[];
  dependencies?: string[];
  priority?: number;
  estimatedComplexity: 'low' | 'medium' | 'high';
  estimatedResources: {
    timeMinutes: number;
[2025-09-10T15:52:43] tokens used: 321

[2025-09-10T15:52:47] thinking

**Considering agent utility design**

I need to create a "multi-agent coordination utility." Maybe I should call it CoordinatorAgent or put it in src/utils. The instruction specifies creating TypeScript files that follow the BaseAgent pattern and registering in AgentFactory. So it seems I need to implement a new agent that coordinates multiple agents. I’m pondering names like "CoordinatorAgent" or "CoordinationAgent," possibly even "MissionControl," which was referenced earlier. I should search for more references.
[2025-09-10T15:52:48] exec bash -lc 'rg -n "MissionControl|CoordinatorAgent|CoordinationAgent|Multi-?Agent|Coordinator" -S src || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:49] bash -lc 'rg -n "MissionControl|CoordinatorAgent|CoordinationAgent|Multi-?Agent|Coordinator" -S src || true' succeeded in 53ms:
src/orchestrator/strategicOrchestrator.ts:5:import { ExecutionCoordinator } from './executionCoordinator.js';
src/orchestrator/strategicOrchestrator.ts:13:  private coordinator = new ExecutionCoordinator();
src/orchestrator/executionCoordinator.ts:10:export class ExecutionCoordinator {
src/masterControl/projectRegistry.ts:119:        agents: ['AgentSummoner', 'MissionControl', 'ResearchAgent'],
src/dashboard/dashboardServer.ts:6:import { MissionControl } from './missionControl.js';
src/dashboard/dashboardServer.ts:17:  private missionControl = new MissionControl();
src/dashboard/missionControl.ts:11:export interface MissionControlStatus {
src/dashboard/missionControl.ts:28:export class MissionControl {
src/dashboard/missionControl.ts:33:  private alerts: MissionControlStatus['alerts'] = [];
src/dashboard/missionControl.ts:37:  async getStatus(): Promise<MissionControlStatus> {
src/dashboard/enhancedMissionControl.ts:3:import { MissionControl, MissionControlStatus } from './missionControl.js';
src/dashboard/enhancedMissionControl.ts:29:export interface EnhancedMissionControlStatus extends MissionControlStatus {
src/dashboard/enhancedMissionControl.ts:50:export class EnhancedMissionControl extends MissionControl {
src/dashboard/enhancedMissionControl.ts:150:  async getEnhancedStatus(): Promise<EnhancedMissionControlStatus> {
src/agents/oradeaBusinessAgent.ts:81:          position: "Partnership Coordinator",
[2025-09-10T15:52:49] tokens used: 816
[2025-09-10T15:52:50] exec bash -lc "sed -n '1,240p' src/orchestrator/executionCoordinator.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:50] bash -lc "sed -n '1,240p' src/orchestrator/executionCoordinator.ts" succeeded in 19ms:
import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
import { AgentFactory } from './agentFactory.js';

export interface ExecutionOptions {
  dryRun?: boolean;
  timeoutMs?: number;
  concurrency?: number; // max agents in parallel
}

export class ExecutionCoordinator {
  private factory = new AgentFactory();

  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
    const results: AgentResult[] = [];
    const ctxShared: Record<string, any> = {};
    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);

    for (const batch of plan.parallelBatches) {
      // Throttle within batch to configured concurrency
      const queue = [...batch];
[2025-09-10T15:52:50] tokens used: 7119

[2025-09-10T15:52:53] thinking

**Exploring coordination utilities**

I see there’s already an execution coordinator in place. The user is requesting a utility for multi-agent coordination in TypeScript. It sounds like we might need to create something that facilitates message passing between agents, possibly a bus for messaging. I’ll want to look into the existing messaging directory to ensure we’re aligned and can effectively build this utility. This would help streamline communication between agents!
[2025-09-10T15:52:55] exec bash -lc "ls -la src/messaging && sed -n '1,220p' src/messaging/agentAdapter.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:55] bash -lc "ls -la src/messaging && sed -n '1,220p' src/messaging/agentAdapter.ts" succeeded in 34ms:
total 16
drwxr-xr-x   4 panda  staff   128 Sep 10 18:50 .
drwxr-xr-x  21 panda  staff   672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff  2042 Sep 10 18:50 agentAdapter.ts
-rw-r--r--   1 panda  staff  2496 Sep 10 18:50 messageBus.ts
import type { BaseAgent } from '../agents/baseAgent.js';
import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
import { MessageBus } from './messageBus.js';

export class AgentAdapter {
  private unsubscribes: Array<() => void> = [];

  constructor(private readonly bus: MessageBus) {}

  register(agent: BaseAgent, spec: AgentSpec) {
    const topics = [
      `task.assign/${spec.requirementId}`,
      `task.assign/agent/${spec.id}`,
    ];
[2025-09-10T15:52:55] tokens used: 674
[2025-09-10T15:52:58] exec bash -lc "sed -n '1,260p' src/messaging/messageBus.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:52:58] bash -lc "sed -n '1,260p' src/messaging/messageBus.ts" succeeded in 21ms:
import { EventEmitter } from 'node:events';
import { randomUUID } from 'node:crypto';
import { z } from 'zod';
import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';

type Handler<T> = (msg: T) => void | Promise<void>;

export class MessageBus {
  private ee = new EventEmitter();

  publish<T extends object>(topic: BusTopic, message: T): void {
    this.ee.emit(topic, message);
  }

  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
    const bound = (msg: T) => handler(msg);
    this.ee.on(topic, bound);
    return () => this.ee.off(topic, bound);
  }
[2025-09-10T15:52:59] tokens used: 823
[2025-09-10T15:53:00] exec bash -lc "ls -la src/protocols && sed -n '1,240p' src/protocols/messageTypes.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:00] bash -lc "ls -la src/protocols && sed -n '1,240p' src/protocols/messageTypes.ts" succeeded in 31ms:
total 8
drwxr-xr-x   3 panda  staff    96 Sep 10 18:50 .
drwxr-xr-x  21 panda  staff   672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff  1400 Sep 10 18:50 messageTypes.ts
import { z } from 'zod';
import type { AgentResult } from '../orchestrator/types.js';

export const MessageHeaderSchema = z.object({
  id: z.string().uuid().optional(),
  type: z.string(),
  source: z.string().optional(),
  timestamp: z.string().datetime().optional(),
  correlationId: z.string().optional(),
});

export type MessageHeader = z.infer<typeof MessageHeaderSchema>;

export const TaskMessageSchema = z.object({
  header: MessageHeaderSchema,
  body: z.object({
[2025-09-10T15:53:00] tokens used: 826
[2025-09-10T15:53:04] exec bash -lc "sed -n '1,240p' src/orchestrator/strategicOrchestrator.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:04] bash -lc "sed -n '1,240p' src/orchestrator/strategicOrchestrator.ts" succeeded in 74ms:
import { promises as fs } from 'fs';
import path from 'path';
import { TaskAnalyzer } from './taskAnalyzer.js';
import { CapabilityMapper } from './capabilityMapper.js';
import { ExecutionCoordinator } from './executionCoordinator.js';
import { PatternLearner } from '../intelligence/patternLearner.js';
import { ProactiveAdvisor } from '../intelligence/proactiveAdvisor.js';
import { AnalyzedTask, OrchestrationPlan, OrchestrationResult } from './types.js';

export class StrategicOrchestrator {
  private analyzer = new TaskAnalyzer();
  private mapper = new CapabilityMapper();
  private coordinator = new ExecutionCoordinator();
  private learner = new PatternLearner();
  private advisor = new ProactiveAdvisor();
  private baseDir = 'logs/orchestrator';

  private async saveJson(rel: string, data: any) {
    const out = path.join(this.baseDir, rel);
    await fs.mkdir(path.dirname(out), { recursive: true });
[2025-09-10T15:53:04] tokens used: 711

[2025-09-10T15:53:07] thinking

**Exploring multi-agent coordination**

I’m looking at an existing system that includes planning and execution. There’s the idea of a multi-agent coordination utility to manage tasks like concurrency and error tracking. The request seems to be about creating TypeScript files for this utility focusing on, reusable coordination, not just agent execution.

Given the instruction to follow the BaseAgent pattern in src/agents/ and register in AgentFactory, it seems like they want agents that implement this utility. Maybe a "CoordinatorAgent" could manage other agents through the message bus. I’ll check src/cli/demo_eufm_agents.ts for more details.
[2025-09-10T15:53:11] exec bash -lc "sed -n '1,240p' src/cli/demo_eufm_agents.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:11] bash -lc "sed -n '1,240p' src/cli/demo_eufm_agents.ts" succeeded in 53ms:
import { randomUUID } from 'node:crypto';
import { AgentFactory } from '../orchestrator/agentFactory.js';
import type { AgentSpec } from '../orchestrator/types.js';
import { MessageBus } from '../messaging/messageBus.js';
import { AgentAdapter } from '../messaging/agentAdapter.js';
import { ResultAggregator } from '../aggregation/resultAggregator.js';

async function main() {
  const bus = new MessageBus();
  const factory = new AgentFactory();
  const aggregator = new ResultAggregator();
  const adapter = new AgentAdapter(bus);

  // Minimal demo specs using existing agents in repo
  const specs: AgentSpec[] = [
    {
      id: 'agent:smoke:1',
      type: 'SmokeTestAgent',
      requirementId: 'req:hello',
      capabilities: ['meta_analysis'],
[2025-09-10T15:53:11] tokens used: 1465
[2025-09-10T15:53:13] exec bash -lc "ls -la src/aggregation && sed -n '1,240p' src/aggregation/resultAggregator.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:13] bash -lc "ls -la src/aggregation && sed -n '1,240p' src/aggregation/resultAggregator.ts" succeeded in 68ms:
total 8
drwxr-xr-x   3 panda  staff   96 Sep 10 18:50 .
drwxr-xr-x  21 panda  staff  672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff  919 Sep 10 18:50 resultAggregator.ts
import type { AgentResult } from '../orchestrator/types.js';

export class ResultAggregator {
  private results: AgentResult[] = [];

  add(result: AgentResult) {
    this.results.push(result);
  }

  getAll(): AgentResult[] {
    return [...this.results];
  }

  success(): boolean {
    return this.results.length > 0 && this.results.every((r) => r.success);
  }
[2025-09-10T15:53:13] tokens used: 936

[2025-09-10T15:53:17] thinking

**Evaluating multi-agent coordination**

I'm considering what we need to add for existing infrastructure. A "multi-agent coordination utility" could help, using MessageBus to manage multiple agents for a project like EUFM. I’m thinking about a "CoordinationManager" that registers agents, dispatches tasks, and aggregates results while handling timeouts and logging events. 

Following the BaseAgent pattern in src/agents, I might create a "CoordinatorAgent" call or it "EUFMMultiAgentCoordinator" or "CoordinationAgent." I also need to update `types.ts` to include this new agent type and create tests in the `src/tests` folder.
[2025-09-10T15:53:21] exec bash -lc "ls -la src/tests && sed -n '1,220p' src/tests/eufm_integration_test.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:21] bash -lc "ls -la src/tests && sed -n '1,220p' src/tests/eufm_integration_test.ts" succeeded in 124ms:
total 32
drwxr-xr-x   6 panda  staff   192 Sep  8 17:09 .
drwxr-xr-x  21 panda  staff   672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff  1477 Sep  6 21:08 countryCodes_test.ts
-rw-r--r--   1 panda  staff  2605 Sep  8 17:09 deadlineValidator_test.ts
-rw-r--r--   1 panda  staff  1483 Sep  6 21:12 euFundingProposalAgent_test.ts
-rw-r--r--   1 panda  staff  1416 Sep  6 17:22 eufm_integration_test.ts
import { AgentFactory } from '../orchestrator/agentFactory.js';
import type { AgentSpec, AgentResult } from '../orchestrator/types.js';

/**
 * Simple integration demo: constructs a TestAgent via AgentFactory and runs it.
 * Safe to run without external APIs or network.
 */
export async function runAgentIntegrationDemo(input: string): Promise<AgentResult> {
  const factory = new AgentFactory();

  const spec: AgentSpec = {
    id: 'agent-test-1',
    type: 'TestAgent',
[2025-09-10T15:53:21] tokens used: 624

[2025-09-10T15:53:24] thinking

**Planning for utility testing**

I’m thinking we should add a test that follows a similar pattern to our current ones for the new coordination utility. I also need to check the tsconfig and package.json files to make sure we can run tsx properly. Ensuring everything is set up correctly will be key for smooth testing, so I want to be thorough. Let's make sure to cover all the bases before diving in!
[2025-09-10T15:53:26] exec bash -lc 'cat package.json && cat tsconfig.json' in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:27] bash -lc 'cat package.json && cat tsconfig.json' succeeded in 29ms:
{
  "name": "eufm",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc -p .",
    "start": "node dist/cli/index.js",
    "dev": "tsx src/cli/index.ts",
    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
    "lint": "eslint .",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
    "test:country-codes": "tsx src/tests/countryCodes_test.ts",
    "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
    "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
  },
  "dependencies": {
    "@notionhq/client": "^5.0.0",
    "@types/express": "^5.0.3",
[2025-09-10T15:53:27] tokens used: 799

[2025-09-10T15:53:29] thinking

**Considering file organization**

I’m thinking about where to add files in the `src` folder. The coordination utility might fit well in `src/utils/coordination`. I’ll need to take a closer look at the existing utils to make sure this makes sense. It’s important to keep things organized! I want to ensure that whatever I choose maintains clarity and accessibility for anyone else who might be working on this project. Let’s move forward with that plan.
[2025-09-10T15:53:31] exec bash -lc 'ls -la src/utils && rg -n "coord|coordin|bus|aggregate|timeline|progress" -S src/utils || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:31] bash -lc 'ls -la src/utils && rg -n "coord|coordin|bus|aggregate|timeline|progress" -S src/utils || true' succeeded in 56ms:
total 56
drwxr-xr-x   6 panda  staff   192 Sep 10 15:13 .
drwxr-xr-x  21 panda  staff   672 Sep 10 18:50 ..
-rw-r--r--   1 panda  staff  2366 Sep  6 21:08 countryCodes.ts
-rw-r--r--   1 panda  staff  4704 Sep  8 17:09 deadlineValidator.ts
-rw-r--r--   1 panda  staff   613 Sep 10 14:04 paths.ts
-rw-r--r--   1 panda  staff  8370 Sep 10 15:13 sessionMemoryUpdater.ts
src/utils/sessionMemoryUpdater.ts:105:    return `Major Progress This Session:
[2025-09-10T15:53:31] tokens used: 675

[2025-09-10T15:53:38] thinking

**Checking test implementations**

I need to remember to test changes before wrapping things up, especially since I've got the approvals in place. I think it’s best to run tests now because full access can be a bit risky. It feels good to be in a testing phase! Now, let's take a look at the TestAgent implementation to understand how to call it properly. This should give me clarity on the next steps.
[2025-09-10T15:53:41] exec bash -lc "sed -n '1,220p' src/agents/testAgent.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:53:41] bash -lc "sed -n '1,220p' src/agents/testAgent.ts" succeeded in 61ms:
import { BaseAgent, AgentRunOptions, AgentContext } from './baseAgent.js';
import { AgentResult } from '../orchestrator/types.js';

/**
 * TestAgent: a minimal agent used to validate integration.
 * - Echoes the input and context
 * - Never calls external services
 */
export class TestAgent extends BaseAgent {
  get type() { return 'TestAgent'; }

  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      if (!opts?.input || typeof opts.input !== 'string') {
        throw new Error('Invalid input: expected non-empty string');
      }

      if (opts.dryRun) {
        return {
[2025-09-10T15:53:41] tokens used: 567

[2025-09-10T15:53:50] thinking

**Implementing tests**

I want to run tests in `src/tests/multiAgentCoordinator_test.ts`. It involves creating two AgentSpec instances, either SmokeTestAgent and TestAgent or MemoryAgent, and using MultiAgentCoordinator for registration and execution. I’ll check that the aggregated results are successful. Since the instruction advises testing changes first, I'll run the script to see if it prints correctly. Although updating isn exports’t necessary, I feel like it’s alright to include. So, I’ll implement the code now!
[2025-09-10T15:53:52] codex

Next, I’ll add the coordination utility, a CoordinationAgent following BaseAgent, update AgentFactory and types, and write a small integration test.
[2025-09-10T15:54:01] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/utils/multiAgentCoordinator.ts
import { randomUUID } from 'node:crypto';
import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
import { MessageBus } from '../messaging/messageBus.js';
import { AgentAdapter } from '../messaging/agentAdapter.js';
import { AgentFactory } from '../orchestrator/agentFactory.js';

export interface CoordinationPlan {
  taskId?: string;
  agents: AgentSpec[];
  inputs: Record<string, string>; // requirementId -> input
  timeoutMs?: number;
  concurrency?: number;
  dryRun?: boolean;
}

export interface CoordinationResultSummary {
  taskId: string;
  results: AgentResult[];
  success: boolean;
  errors: string[];
}

/**
 * MultiAgentCoordinator
 * - Registers agents on a local in-memory MessageBus
 * - Dispatches tasks to agents by requirementId
 * - Gathers results and aggregates success/errors
 */
export class MultiAgentCoordinator {
  private readonly bus: MessageBus;
  private readonly adapter: AgentAdapter;
  private readonly factory = new AgentFactory();
  private disposables: Array<() => void> = [];

  constructor(bus?: MessageBus) {
    this.bus = bus ?? new MessageBus();
    this.adapter = new AgentAdapter(this.bus);
  }

  /** Register and wire up agents to the bus */
  registerAgents(specs: AgentSpec[]) {
    for (const spec of specs) {
      const agent = this.factory.create(spec);
      this.adapter.register(agent, spec);
    }
  }

  /**
   * Execute the plan and return aggregated results.
   * Uses request/reply to await each agent’s result with optional concurrency.
   */
  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
    const taskId = plan.taskId ?? randomUUID();
    const timeoutMs = plan.timeoutMs ?? 15_000;
    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);

    const queue = [...plan.agents];
    const results: AgentResult[] = [];
    const errors: string[] = [];

    const runForSpec = async (spec: AgentSpec) => {
      const input = plan.inputs[spec.requirementId] ?? '';
      try {
        const res: any = await this.bus.request(
          `task.assign/${spec.requirementId}`,
          {
            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
            body: {
              taskId,
              requirementId: spec.requirementId,
              input,
              params: spec.params ?? {},
              timeoutMs,
              dryRun: plan.dryRun,
            },
          },
          { timeoutMs }
        );
        const result: AgentResult | undefined = res?.body?.result;
        if (result) results.push(result);
        else errors.push(`No result from ${spec.type}/${spec.id}`);
      } catch (err: any) {
        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
      }
    };

    const active: Promise<void>[] = [];
    while (queue.length > 0 || active.length > 0) {
      while (active.length < concurrency && queue.length > 0) {
        const spec = queue.shift()!;
        const p = runForSpec(spec).finally(() => {
          const idx = active.indexOf(p as any);
          if (idx >= 0) active.splice(idx, 1);
        });
        active.push(p as any);
      }
      if (active.length > 0) {
        await Promise.race(active).catch(() => {});
      }
    }

    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
    return { taskId, results, success, errors };
  }

  dispose() {
    try { this.adapter.dispose(); } catch {}
    this.disposables.forEach((d) => {
      try { d(); } catch {}
    });
    this.disposables = [];
  }
}

[2025-09-10T15:54:01] apply_patch(auto_approved=true) exited 0 in 83ms:
Success. Updated the following files:
A src/utils/multiAgentCoordinator.ts
[2025-09-10T15:54:01] turn diff:
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:01] tokens used: 2368
[2025-09-10T15:54:01] turn diff:
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

A /Users/panda/Desktop/UBOS/src/agents/coordinationAgent.ts
import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
import { MessageBus } from '../messaging/messageBus.js';

export interface CoordinationParams {
  agents: AgentSpec[];
  inputs: Record<string, string>; // requirementId -> input
  timeoutMs?: number;
  concurrency?: number;
  dryRun?: boolean;
}

/**
 * CoordinationAgent
 * An agent that coordinates multiple sub-agents using the MessageBus-based
 * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
 */
export class CoordinationAgent extends BaseAgent {
  get type() { return 'CoordinationAgent'; }

  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
    const startedAt = this.now();
    try {
      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
      }
[2025-09-10T15:54:13] apply_patch auto_approved=true:
      if (!params.inputs || typeof params.inputs !== 'object') {
        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
      }

      if (opts.dryRun) {
        return {
          agentId: this.id,
          requirementId: this.requirementId,
          success: true,
          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
          startedAt,
          finishedAt: this.now(),
          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
        };
      }

      const bus = new MessageBus();
      const coordinator = new MultiAgentCoordinator(bus);
      coordinator.registerAgents(params.agents);
      const summary = await coordinator.execute({
        agents: params.agents,
        inputs: params.inputs,
        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
        concurrency: params.concurrency,
        dryRun: params.dryRun ?? opts.dryRun,
      });

      const lines: string[] = [];
      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
      for (const r of summary.results) {
        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
      }
      if (summary.errors.length) {
        lines.push('Errors:');
        summary.errors.forEach((e) => lines.push(`  - ${e}`));
      }

      return {
        agentId: this.id,
        requirementId: this.requirementId,
        success: summary.success,
        output: lines.join('\n'),
        artifacts: {
          results: summary.results,
          errors: summary.errors,
          taskId: summary.taskId,
        },
        startedAt,
        finishedAt: this.now(),
      };
    } catch (e: any) {
      const errMsg = e?.message || String(e);
      return {
        agentId: this.id,
        requirementId: this.requirementId,
        success: false,
        output: '',
        error: errMsg,
        startedAt,
        finishedAt: this.now(),
      };
    }
  }
}

[2025-09-10T15:54:13] apply_patch(auto_approved=true) exited 0 in 423ms:
Success. Updated the following files:
A src/agents/coordinationAgent.ts
[2025-09-10T15:54:13] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:13] tokens used: 2419
[2025-09-10T15:54:13] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:17] apply_patch auto_approved=true:
M /Users/panda/Desktop/UBOS/src/orchestrator/types.ts
@@ -52,3 +52,4 @@
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
[2025-09-10T15:54:17] apply_patch(auto_approved=true) exited 0 in 488ms:
Success. Updated the following files:
M src/orchestrator/types.ts
[2025-09-10T15:54:17] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:17] tokens used: 1198
[2025-09-10T15:54:17] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:21] apply_patch auto_approved=true:
M /Users/panda/Desktop/UBOS/src/orchestrator/agentFactory.ts
@@ -17,2 +17,3 @@
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
@@ -37,2 +38,3 @@
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
[2025-09-10T15:54:22] apply_patch(auto_approved=true) exited 0 in 353ms:
Success. Updated the following files:
M src/orchestrator/agentFactory.ts
[2025-09-10T15:54:22] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:22] tokens used: 376
[2025-09-10T15:54:22] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:42] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/tests/multiAgentCoordinator_test.ts
import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
import { MessageBus } from '../messaging/messageBus.js';
import { AgentFactory } from '../orchestrator/agentFactory.js';
import type { AgentSpec } from '../orchestrator/types.js';

async function runCoordinatorDemo() {
  const bus = new MessageBus();
  const coordinator = new MultiAgentCoordinator(bus);

  const specs: AgentSpec[] = [
    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
  ];

  coordinator.registerAgents(specs);

  const inputs = {
    'req:hello': 'Say hello from MultiAgentCoordinator test.',
    'req:test': 'Echo this input and context.',
  };

  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });

  // eslint-disable-next-line no-console
  console.log('\n=== MultiAgentCoordinator Summary ===');
  // eslint-disable-next-line no-console
  console.log(`Success: ${summary.success}`);
  // eslint-disable-next-line no-console
  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);

  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
}

async function runCoordinationAgentDemo() {
  const factory = new AgentFactory();

  const subAgents: AgentSpec[] = [
    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
  ];

  const inputs = {
    'req:hello2': 'Hello from CoordinationAgent demo.',
    'req:test2': 'Please echo cleanly.',
  };

  const agentSpec: AgentSpec = {
    id: 'coord-1',
    type: 'CoordinationAgent',
    requirementId: 'req:coord',
    capabilities: ['meta_analysis'],
  };

  const agent = factory.create(agentSpec);
  const res = await agent.run(
    { input: 'Coordinate agents', timeoutMs: 15_000 },
    { shared: { agents: subAgents, inputs } }
  );

  // eslint-disable-next-line no-console
  console.log('\n=== CoordinationAgent Result ===');
  // eslint-disable-next-line no-console
  console.log(res.output);
  if (!res.success) throw new Error('CoordinationAgent failed');
}

// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
if (import.meta.url === `file://${process.argv[1]}`) {
  (async () => {
    try {
      await runCoordinatorDemo();
      await runCoordinationAgentDemo();
      // eslint-disable-next-line no-console
      console.log('\nAll coordination demos passed.');
    } catch (err: any) {
      // eslint-disable-next-line no-console
      console.error('Coordination demos failed:', err?.message || err);
      process.exitCode = 1;
    }
  })();
}

[2025-09-10T15:54:43] apply_patch(auto_approved=true) exited 0 in 780ms:
Success. Updated the following files:
A src/tests/multiAgentCoordinator_test.ts
[2025-09-10T15:54:43] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:43] tokens used: 1309
[2025-09-10T15:54:43] turn diff:
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:46] thinking

**Considering npm
 scripts**

I’m thinking about adding an npm script, specifically one labeled `test:coord`. It’s not strictly necessary, but it could be quite helpful. I want to ensure that my setup is efficient and user-friendly, so having an optional script like this might simplify testing. Let's see if it makes sense to incorporate; I think it would enhance the overall experience!
[2025-09-10T15:54:49] apply_patch auto_approved=true:
M /Users/panda/Desktop/UBOS/package.json
@@ -14,2 +14,3 @@
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
[2025-09-10T15:54:49] apply_patch(auto_approved=true) exited 0 in 607ms:
Success. Updated the following files:
M package.json
[2025-09-10T15:54:49] turn diff:
diff --git a/package.json b/package.json
index 81cabcef4ca40ab66bc867bebaec9514904123e1..7dd8b311be6def660626c1c7ad92d2ad0c029791
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:file-writer": "tsx src/tests/fileWriter_test.ts",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
     "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
     "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:49] tokens used: 1082
[2025-09-10T15:54:49] turn diff:
diff --git a/package.json b/package.json
index 81cabcef4ca40ab66bc867bebaec9514904123e1..7dd8b311be6def660626c1c7ad92d2ad0c029791
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:file-writer": "tsx src/tests/fileWriter_test.ts",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
     "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
     "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:54:52] exec bash -lc 'npm run -s typecheck' in /Users/panda/Desktop/UBOS
[2025-09-10T15:55:09] bash -lc 'npm run -s typecheck' succeeded in 16.30s:

[2025-09-10T15:55:09] tokens used: 155
[2025-09-10T15:55:09] turn diff:
diff --git a/package.json b/package.json
index 81cabcef4ca40ab66bc867bebaec9514904123e1..7dd8b311be6def660626c1c7ad92d2ad0c029791
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:file-writer": "tsx src/tests/fileWriter_test.ts",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
     "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
     "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+

[2025-09-10T15:55:10] exec bash -lc 'npm run -s test:coord' in /Users/panda/Desktop/UBOS
[2025-09-10T15:55:13] bash -lc 'npm run -s test:coord' succeeded in 2.73s:
[2025-09-10T15:55:13] turn diff:
diff --git a/package.json b/package.json
index 81cabcef4ca40ab66bc867bebaec9514904123e1..7dd8b311be6def660626c1c7ad92d2ad0c029791
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:file-writer": "tsx src/tests/fileWriter_test.ts",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
     "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
     "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+


=== MultiAgentCoordinator Summary ===
Success: true
Results: 2, Errors: 0

=== CoordinationAgent Result ===
Coordination complete: 2 result(s).
Success: yes
- smoke-2/req:hello2: OK
- test-2/req:test2: OK

All coordination demos passed.
[2025-09-10T15:55:13] tokens used: 100

[2025-09-10T15:55:16] thinking

**Summarizing changes in documentation**

I’m considering whether to add documentation. While it's not strictly necessary, minimal documentation might still be helpful. I have to remember to preserve existing functionality, follow TypeScript best practices, and ensure error handling and logging are in place — which I’ve covered. We also introduced a new type union, and there shouldn’t be any breakages. I’ll make sure the imports include the .js extension too, aligning with the ESM pattern. Time to craft a final message summarizing the changes!
[2025-09-10T15:55:18] codex

**What I Added**

- Multi-agent coordination utility
  - `src/utils/multiCoordinatorAgent.ts`
    - Registers agents on an in-memory `MessageBus` via `/replyAgentAdapter`.
    - Dispatches tasks with request, concurrency limits, timeouts, and dry-run support.
    - Aggregates `AgentResult[]` and errors into a clear summary.

- Coordinating agent (follows BaseAgent pattern)
  - `src/agents.ts/coordinationAgent`
    - Type: `CoordinationAgent`
    - Accepts `ctx.shared` with:
      - `agents: AgentSpec[]`
      - `inputs: Record<string,string>` (per requirementId)
      - optional: `timeoutMs`, `concurrency`, `dryRun`
    - Uses the utility to run sub-agents and returns an aggregated result.

- Factory and types updates
  - `src/orchestrator/types.ts`
    - Added `'CoordinationAgent'` to `AgentSpec['type']` union.
  - `src/orchestrator/Factory.tsagent`
    - Registered `CoordinationAgent` creation.

- Tests / demos
  - `src/tests/multiAgentCoordinator_test.ts`
    - 1: Uses Demo `MultiAgentCoordinator` with `SmokeTestAgent` and `TestAgent`.
    - Demo 2: Uses `CoordinationAgent` to coordinate the same style of agents.
  - `package.json`
    - Added script: `test:coord` → `tsx src/tests/multiAgentCoordinator_test.ts`

**How It Works**

- `MultiAgentCoordinator`:
  - `registerAgents(specs)` creates agents via `AgentFactory and` registers them on `MessageBus` through `AgentAdapter`.
  - `execute({ agents, inputs timeout,Ms, concurrency, dryRun })` sends `task.assign/<requirementId>` messages with IDs correlation; collects replies validated by protocol schemas; throttles concurrency; returns `{Id, results task, success, errors }`.

- `CoordinationAgent`:
  - Extends `BaseAgent`.
  - Reads `agents` and `inputs` from `ctx.shared` and coordinates execution through `MultiAgentCoordinator`.
  - Dry run prints a clear summary; on execution, returns aggregated outputs and artifacts.

**Validation**

- Typecheck: Passed (`npm run typecheck`).
- Demo tests: Passed (`npm run test:coord`)
  - Shows success summary for both direct utility and agent-based coordination.

**Notes**

- No existing functionality modified; only extended in a compatible way.
- Uses ESM-compatible imports with `.js` suffix.
- Includes defensive checks and concise error logging in both the utility and agent.

**Next Options**

- Want me to wire this into an existing CLI command or dashboard endpoint?
- Should we add richer progress/timeline events on the bus for UI integration?
[2025-09-10T15:55:24] tokens used: 860
[2025-09-10T15:55:24] turn diff:
diff --git a/package.json b/package.json
index 81cabcef4ca40ab66bc867bebaec9514904123e1..7dd8b311be6def660626c1c7ad92d2ad0c029791
--- a/package.json
+++ b/package.json
@@ -12,6 +12,7 @@
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:file-writer": "tsx src/tests/fileWriter_test.ts",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
+    "test:coord": "tsx src/tests/multiAgentCoordinator_test.ts",
     "test:country-codes": "tsx src/tests/countryCodes_test.ts",
     "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
     "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
diff --git a/src/agents/coordinationAgent.ts b/src/agents/coordinationAgent.ts
new file mode 100644
index 0000000000000000000000000000000000000000..726f3c12625f670b7311219474e9d32733f35ac6
--- /dev/null
+++ b/src/agents/coordinationAgent.ts
@@ -0,0 +1,94 @@
+import { BaseAgent, type AgentRunOptions, type AgentContext } from './baseAgent.js';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+
+export interface CoordinationParams {
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+/**
+ * CoordinationAgent
+ * An agent that coordinates multiple sub-agents using the MessageBus-based
+ * MultiAgentCoordinator. It expects coordination parameters in ctx.shared.
+ */
+export class CoordinationAgent extends BaseAgent {
+  get type() { return 'CoordinationAgent'; }
+
+  async run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult> {
+    const startedAt = this.now();
+    try {
+      const params = (ctx?.shared || {}) as Partial<CoordinationParams>;
+      if (!params.agents || !Array.isArray(params.agents) || params.agents.length === 0) {
+        throw new Error('CoordinationAgent requires ctx.shared.agents: AgentSpec[]');
+      }
+      if (!params.inputs || typeof params.inputs !== 'object') {
+        throw new Error('CoordinationAgent requires ctx.shared.inputs: Record<string,string>');
+      }
+
+      if (opts.dryRun) {
+        return {
+          agentId: this.id,
+          requirementId: this.requirementId,
+          success: true,
+          output: `[Dry run] Would coordinate ${params.agents.length} agent(s).`,
+          startedAt,
+          finishedAt: this.now(),
+          metadata: { coordinator: true, agents: params.agents.map((a) => a.type) },
+        };
+      }
+
+      const bus = new MessageBus();
+      const coordinator = new MultiAgentCoordinator(bus);
+      coordinator.registerAgents(params.agents);
+      const summary = await coordinator.execute({
+        agents: params.agents,
+        inputs: params.inputs,
+        timeoutMs: params.timeoutMs ?? opts.timeoutMs,
+        concurrency: params.concurrency,
+        dryRun: params.dryRun ?? opts.dryRun,
+      });
+
+      const lines: string[] = [];
+      lines.push(`Coordination complete: ${summary.results.length} result(s).`);
+      lines.push(`Success: ${summary.success ? 'yes' : 'no'}`);
+      for (const r of summary.results) {
+        lines.push(`- ${r.agentId}/${r.requirementId}: ${r.success ? 'OK' : 'ERR'}`);
+      }
+      if (summary.errors.length) {
+        lines.push('Errors:');
+        summary.errors.forEach((e) => lines.push(`  - ${e}`));
+      }
+
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: summary.success,
+        output: lines.join('\n'),
+        artifacts: {
+          results: summary.results,
+          errors: summary.errors,
+          taskId: summary.taskId,
+        },
+        startedAt,
+        finishedAt: this.now(),
+      };
+    } catch (e: any) {
+      const errMsg = e?.message || String(e);
+      return {
+        agentId: this.id,
+        requirementId: this.requirementId,
+        success: false,
+        output: '',
+        error: errMsg,
+        startedAt,
+        finishedAt: this.now(),
+      };
+    }
+  }
+}
+
diff --git a/src/orchestrator/agentFactory.ts b/src/orchestrator/agentFactory.ts
index 5314246e352105bb8e59ea4005efc7e99ed79dc0..33f960f76656b145f4c26fca65be6c74309e70c0
--- a/src/orchestrator/agentFactory.ts
+++ b/src/orchestrator/agentFactory.ts
@@ -15,6 +15,7 @@
 import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
 import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
 import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';
+import { CoordinationAgent } from '../agents/coordinationAgent.js';
 
 export class AgentFactory {
   create(spec: AgentSpec): BaseAgent {
@@ -35,6 +36,7 @@
       case 'TestAgent': return new TestAgent(id, requirementId);
       case 'figma-mcp': return new FigmaMCPAgent(id, requirementId);
       case 'spec-kit-codex': return new SpecKitCodexAgent(id, requirementId);
+      case 'CoordinationAgent': return new CoordinationAgent(id, requirementId);
       default:
         throw new Error(`Unknown agent type: ${type}`);
     }
diff --git a/src/orchestrator/types.ts b/src/orchestrator/types.ts
index d80da6272ca09df8b8600456e8467e90d9b0608d..f00083e649fc337c8f805505f03d13fb56060340
--- a/src/orchestrator/types.ts
+++ b/src/orchestrator/types.ts
@@ -50,7 +50,8 @@
     | 'MemoryAgent'
     | 'TestAgent'
     | 'figma-mcp'
-    | 'spec-kit-codex';
+    | 'spec-kit-codex'
+    | 'CoordinationAgent';
   requirementId: string;
   capabilities: Capability[];
   params?: Record<string, any>;
diff --git a/src/tests/multiAgentCoordinator_test.ts b/src/tests/multiAgentCoordinator_test.ts
new file mode 100644
index 0000000000000000000000000000000000000000..70ebdefc153c185a24679d55d0ef67c507722747
--- /dev/null
+++ b/src/tests/multiAgentCoordinator_test.ts
@@ -0,0 +1,82 @@
+import { MultiAgentCoordinator } from '../utils/multiAgentCoordinator.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+
+async function runCoordinatorDemo() {
+  const bus = new MessageBus();
+  const coordinator = new MultiAgentCoordinator(bus);
+
+  const specs: AgentSpec[] = [
+    { id: 'smoke-1', type: 'SmokeTestAgent', requirementId: 'req:hello', capabilities: ['meta_analysis'] },
+    { id: 'test-1', type: 'TestAgent', requirementId: 'req:test', capabilities: ['memory'], params: { note: 'from-multiAgent-demo' } },
+  ];
+
+  coordinator.registerAgents(specs);
+
+  const inputs = {
+    'req:hello': 'Say hello from MultiAgentCoordinator test.',
+    'req:test': 'Echo this input and context.',
+  };
+
+  const summary = await coordinator.execute({ agents: specs, inputs, timeoutMs: 10_000, concurrency: 2 });
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== MultiAgentCoordinator Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(`Success: ${summary.success}`);
+  // eslint-disable-next-line no-console
+  console.log(`Results: ${summary.results.length}, Errors: ${summary.errors.length}`);
+
+  if (!summary.success) throw new Error('Coordinator summary unsuccessful');
+}
+
+async function runCoordinationAgentDemo() {
+  const factory = new AgentFactory();
+
+  const subAgents: AgentSpec[] = [
+    { id: 'smoke-2', type: 'SmokeTestAgent', requirementId: 'req:hello2', capabilities: ['meta_analysis'] },
+    { id: 'test-2', type: 'TestAgent', requirementId: 'req:test2', capabilities: ['memory'], params: { note: 'from-coordination-agent' } },
+  ];
+
+  const inputs = {
+    'req:hello2': 'Hello from CoordinationAgent demo.',
+    'req:test2': 'Please echo cleanly.',
+  };
+
+  const agentSpec: AgentSpec = {
+    id: 'coord-1',
+    type: 'CoordinationAgent',
+    requirementId: 'req:coord',
+    capabilities: ['meta_analysis'],
+  };
+
+  const agent = factory.create(agentSpec);
+  const res = await agent.run(
+    { input: 'Coordinate agents', timeoutMs: 15_000 },
+    { shared: { agents: subAgents, inputs } }
+  );
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== CoordinationAgent Result ===');
+  // eslint-disable-next-line no-console
+  console.log(res.output);
+  if (!res.success) throw new Error('CoordinationAgent failed');
+}
+
+// Allow running directly with `tsx src/tests/multiAgentCoordinator_test.ts`
+if (import.meta.url === `file://${process.argv[1]}`) {
+  (async () => {
+    try {
+      await runCoordinatorDemo();
+      await runCoordinationAgentDemo();
+      // eslint-disable-next-line no-console
+      console.log('\nAll coordination demos passed.');
+    } catch (err: any) {
+      // eslint-disable-next-line no-console
+      console.error('Coordination demos failed:', err?.message || err);
+      process.exitCode = 1;
+    }
+  })();
+}
+
diff --git a/src/utils/multiAgentCoordinator.ts b/src/utils/multiAgentCoordinator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9df8a425d7b4bb03193be20970d0847c0a745b90
--- /dev/null
+++ b/src/utils/multiAgentCoordinator.ts
@@ -0,0 +1,114 @@
+import { randomUUID } from 'node:crypto';
+import type { AgentResult, AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+
+export interface CoordinationPlan {
+  taskId?: string;
+  agents: AgentSpec[];
+  inputs: Record<string, string>; // requirementId -> input
+  timeoutMs?: number;
+  concurrency?: number;
+  dryRun?: boolean;
+}
+
+export interface CoordinationResultSummary {
+  taskId: string;
+  results: AgentResult[];
+  success: boolean;
+  errors: string[];
+}
+
+/**
+ * MultiAgentCoordinator
+ * - Registers agents on a local in-memory MessageBus
+ * - Dispatches tasks to agents by requirementId
+ * - Gathers results and aggregates success/errors
+ */
+export class MultiAgentCoordinator {
+  private readonly bus: MessageBus;
+  private readonly adapter: AgentAdapter;
+  private readonly factory = new AgentFactory();
+  private disposables: Array<() => void> = [];
+
+  constructor(bus?: MessageBus) {
+    this.bus = bus ?? new MessageBus();
+    this.adapter = new AgentAdapter(this.bus);
+  }
+
+  /** Register and wire up agents to the bus */
+  registerAgents(specs: AgentSpec[]) {
+    for (const spec of specs) {
+      const agent = this.factory.create(spec);
+      this.adapter.register(agent, spec);
+    }
+  }
+
+  /**
+   * Execute the plan and return aggregated results.
+   * Uses request/reply to await each agent’s result with optional concurrency.
+   */
+  async execute(plan: CoordinationPlan): Promise<CoordinationResultSummary> {
+    const taskId = plan.taskId ?? randomUUID();
+    const timeoutMs = plan.timeoutMs ?? 15_000;
+    const concurrency = plan.concurrency && plan.concurrency > 0 ? plan.concurrency : Math.min(4, plan.agents.length || 1);
+
+    const queue = [...plan.agents];
+    const results: AgentResult[] = [];
+    const errors: string[] = [];
+
+    const runForSpec = async (spec: AgentSpec) => {
+      const input = plan.inputs[spec.requirementId] ?? '';
+      try {
+        const res: any = await this.bus.request(
+          `task.assign/${spec.requirementId}`,
+          {
+            header: { type: 'task.assign', source: 'MultiAgentCoordinator', timestamp: new Date().toISOString() },
+            body: {
+              taskId,
+              requirementId: spec.requirementId,
+              input,
+              params: spec.params ?? {},
+              timeoutMs,
+              dryRun: plan.dryRun,
+            },
+          },
+          { timeoutMs }
+        );
+        const result: AgentResult | undefined = res?.body?.result;
+        if (result) results.push(result);
+        else errors.push(`No result from ${spec.type}/${spec.id}`);
+      } catch (err: any) {
+        errors.push(`${spec.type}/${spec.id} failed: ${err?.message || String(err)}`);
+      }
+    };
+
+    const active: Promise<void>[] = [];
+    while (queue.length > 0 || active.length > 0) {
+      while (active.length < concurrency && queue.length > 0) {
+        const spec = queue.shift()!;
+        const p = runForSpec(spec).finally(() => {
+          const idx = active.indexOf(p as any);
+          if (idx >= 0) active.splice(idx, 1);
+        });
+        active.push(p as any);
+      }
+      if (active.length > 0) {
+        await Promise.race(active).catch(() => {});
+      }
+    }
+
+    const success = results.length > 0 && results.every((r) => r.success) && errors.length === 0;
+    return { taskId, results, success, errors };
+  }
+
+  dispose() {
+    try { this.adapter.dispose(); } catch {}
+    this.disposables.forEach((d) => {
+      try { d(); } catch {}
+    });
+    this.disposables = [];
+  }
+}
+


Process exited with code: 0
