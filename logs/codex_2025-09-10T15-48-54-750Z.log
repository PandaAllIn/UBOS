Executing: codex exec --dangerously-bypass-approvals-and-sandbox Create file structure, install dependencies, setup TypeScript project with agent communication protocols, task delegation, results aggregation.

Project Context: EUFM (European Union Funds Manager) - AI Agent Orchestration System
Working Directory: /Users/panda/Desktop/UBOS
Project Type: TypeScript/Node.js multi-agent coordination system
Note: Follow the BaseAgent pattern in src/agents/ and register in AgentFactory

Safety Guidelines:
- Preserve existing functionality when modifying files
- Follow TypeScript best practices and existing code patterns
- Add proper error handling and logging
- Test changes before completing
Working Directory: /Users/panda/Desktop/UBOS
Timeout: 600000 ms

[2025-09-10T15:48:54] OpenAI Codex v0.30.0 (research preview)
--------
workdir: /Users/panda/Desktop/UBOS
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-10T15:48:54] User instructions:
Create file structure, install dependencies, setup TypeScript project with agent communication protocols, task delegation, results aggregation.

Project Context: EUFM (European Union Funds Manager) - AI Agent Orchestration System
Working Directory: /Users/panda/Desktop/UBOS
Project Type: TypeScript/Node.js multi-agent coordination system
Note: Follow the BaseAgent pattern in src/agents/ and register in AgentFactory

Safety Guidelines:
- Preserve existing functionality when modifying files
- Follow TypeScript best practices and existing code patterns
- Add proper error handling and logging
- Test changes before completing

[2025-09-10T15:48:59] thinking

**Setting up TypeScript project**

I need to create a file structure for the EUFM AI Agent Orchestration System and set up a TypeScript project. This involves installing dependencies and ensuring effective agent communication protocols, task delegation, and results aggregation. The repo may currently be empty, so I’ll initiate a TypeScript/Node.js project with essential files like package.json and tsconfig.json, while defining the BaseAgent pattern and registering in the AgentFactory. I'll implement messaging, tasks, and necessary tools for logging and validation.
**Creating example agents**

I need to implement minimal example agents, like ResearchAgent, AnalysisAgent, and AggregatorAgent, while focusing on task delegation. The Coordinator will manage tasks, splitting them into subtasks and dispatching them through the MessageBus. Agents will respond with results, which the Aggregator will compile. I plan to provide a CLI entry in src/index.ts for running sample scenarios and include tests. Running ts-node will help demonstrate examples and log results effectively, along with keeping an organized plan for initialization and setup.
**Implementing basic flow**

I need to create a basic workflow where the Coordinator receives a high-level task, delegates it to registered agents via the MessageBus, collects results, and aggregates them for printing. I’ll add a sample run entry point and possibly a small test. After that, I’ll run a build and execute the sample to ensure everything works. I’ll follow any relevant specifications, using commands to initialize npm and install necessary dependencies like TypeScript, pino, zod, and Node's built-in EventEmitter. Let's get started!
[2025-09-10T15:49:11] codex
**Creating example agents**

I need to implement minimal example agents, like ResearchAgent, AnalysisAgent, and AggregatorAgent, while focusing on task delegation. The Coordinator will manage tasks, splitting them into subtasks and dispatching them through the MessageBus. Agents will respond with results, which the Aggregator will compile. I plan to provide a CLI entry in src/index.ts for running sample scenarios and include tests. Running ts-node will help demonstrate examples and log results effectively, along with keeping an organized plan for initialization and setup.
[2025-09-10T15:49:11] codex
**Implementing basic flow**

I need to create a basic workflow where the Coordinator receives a high-level task, delegates it to registered agents via the MessageBus, collects results, and aggregates them for printing. I’ll add a sample run entry point and possibly a small test. After that, I’ll run a build and execute the sample to ensure everything works. I’ll follow any relevant specifications, using commands to initialize npm and install necessary dependencies like TypeScript, pino, zod, and Node's built-in EventEmitter. Let's get started!
[2025-09-10T15:49:11] codex

I’m going to initialize a TypeScript Node project, install dependencies, then scaffold the agents, protocols, coordinator, and a runnable demo.
[2025-09-10T15:49:14] exec bash -lc 'ls -la' in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:14] bash -lc 'ls -la' succeeded in 81ms:
total 1560
drwxr-xr-x   47 panda  staff    1504 Sep 10 16:15 .
drwx------+  17 panda  staff     544 Sep 10 13:39 ..
-rw-r--r--@   1 panda  staff   14340 Sep 10 13:36 .DS_Store
drwxr-xr-x    3 panda  staff      96 Sep 10 16:21 .claude
drwxr-xr-x    3 panda  staff      96 Sep  8 16:46 .cursor
-rw-r--r--    1 panda  staff     798 Sep  8 13:28 .env
-rw-r--r--    1 panda  staff     196 Sep  7 21:10 .env.example
drwxr-xr-x   17 panda  staff     544 Sep 10 16:31 .git
-rw-r--r--    1 panda  staff      45 Sep 10 16:15 .gitattributes
drwxr-xr-x    5 panda  staff     160 Sep 10 16:16 .github
-rw-r--r--    1 panda  staff      71 Sep  8 15:04 .gitignore
drwxr-xr-x    3 panda  staff      96 Sep  9 16:53 .vscode
-rw-r--r--    1 panda  staff    5088 Sep 10 14:05 CODE_OF_CONDUCT.md
-rw-r--r--@   1 panda  staff     458 Sep 10 14:05 CONTRIBUTING.md
drwxr-xr-x    7 panda  staff     224 Sep  7 18:05 PROJECTS
-rw-r--r--@   1 panda  staff     348 Sep 10 14:07 README.md
-rw-r--r--@   1 panda  staff     425 Sep 10 14:05 SECURITY.md
drwxr-xr-x    3 panda  staff      96 Sep  6 18:05 _external
-rw-r--r--    1 panda  staff    7307 Sep  8 18:24 codex_comprehensive_dashboard_analysis.txt
[2025-09-10T15:49:14] tokens used: 946

[2025-09-10T15:49:16] thinking

**Considering project setup**

I see there's already a package.json, a node_modules folder, and existing projects in the workspace. There's also an existing src folder that I need to be careful around, so I won't break any existing functionality. I think we should create a new project directory, possibly under the 'eufm' directory since it has three items in it. I need to double-check what those items are before proceeding!
[2025-09-10T15:49:18] exec bash -lc 'ls -la eufm && rg -n "AGENTS.md|BaseAgent|AgentFactory|EUFM|eufm" -S || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:18] bash -lc 'ls -la eufm && rg -n "AGENTS.md|BaseAgent|AgentFactory|EUFM|eufm" -S || true' succeeded in 155ms:
total 0
drwxr-xr-x   3 panda  staff    96 Sep 10 13:48 .
drwxr-xr-x  47 panda  staff  1504 Sep 10 16:15 ..
drwxr-xr-x  11 panda  staff   352 Sep 10 13:49 docs
src/analytics/autoTracker.ts:2:// - Enabled only when EUFM_TRACK_USAGE=true
src/analytics/autoTracker.ts:17:  return String(process.env.EUFM_TRACK_USAGE || '').toLowerCase() === 'true';
src/masterControl/projectRegistry.ts:133:        synergiesWith: ['eufm_funding']
src/masterControl/projectRegistry.ts:146:        baseDirectory: repoPath('eufm', 'docs', 'xf'),
src/masterControl/projectRegistry.ts:152:    // EUFM Funding Project
src/masterControl/projectRegistry.ts:153:    const eufmProject: ProjectMetadata = {
src/masterControl/projectRegistry.ts:154:      id: 'eufm_funding',
src/masterControl/projectRegistry.ts:155:      name: 'EUFM EU Funding Acquisition',
src/masterControl/projectRegistry.ts:156:      description: 'Secure €2M+ EU funding for EUFM infrastructure scaling',
src/masterControl/projectRegistry.ts:228:        configFile: 'eufm/docs/agents/CLAUDE_SESSION_MEMORY.md',
src/masterControl/projectRegistry.ts:234:    this.projectsData.set(eufmProject.id, eufmProject);
src/adapters/openai.ts:15:			{ role: 'system', content: 'You are EUFM OpenAI adapter.' },
src/orchestrator/executionCoordinator.ts:2:import { AgentFactory } from './agentFactory.js';
src/orchestrator/executionCoordinator.ts:11:  private factory = new AgentFactory();
src/adapters/perplexity.ts:22:        { role: 'system', content: 'You are EUFM Perplexity adapter.' },
src/orchestrator/agentFactory.ts:2:import { BaseAgent } from '../agents/baseAgent.js';
[2025-09-10T15:49:18] tokens used: 1522

[2025-09-10T15:49:21] thinking

**Inspecting codebase structure**

I see there's already a codebase with an orchestrator and agents. I should dive into the `src/orchestrator` and `src/agents` directories to understand how the existing `BaseAgent` pattern works and how the `Factory`Agent is implemented. It’s essential to follow these patterns for any development or changes I plan to make, ensuring consistency and alignment with what’s already in place. So, let’s get started on that exploration!
[2025-09-10T15:49:23] exec bash -lc 'ls -la src/agents src/orchestrator || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:23] bash -lc 'ls -la src/agents src/orchestrator || true' succeeded in 39ms:
src/agents:
total 328
drwxr-xr-x  20 panda  staff    640 Sep 10 15:13 .
drwxr-xr-x  18 panda  staff    576 Sep  9 17:40 ..
-rw-r--r--   1 panda  staff   1069 Sep  3 15:33 abacusAgent.ts
-rw-r--r--   1 panda  staff  16479 Sep  6 20:53 agentSummoner.ts
-rw-r--r--   1 panda  staff  11263 Sep  8 14:52 agentSummonerAgent.ts
-rw-r--r--   1 panda  staff    516 Sep  3 15:32 baseAgent.ts
-rw-r--r--   1 panda  staff   1089 Sep  3 15:33 browserAgent.ts
-rw-r--r--   1 panda  staff   1921 Sep  5 16:32 codexAgent.ts
-rw-r--r--   1 panda  staff   9194 Sep 10 14:04 codexCLIAgent.ts
-rw-r--r--   1 panda  staff  12900 Sep  8 14:52 enhancedAbacusAgent.ts
-rw-r--r--   1 panda  staff   7806 Sep  6 21:12 euFundingProposalAgent.ts
-rw-r--r--   1 panda  staff  17459 Sep 10 15:13 eufmAgentSummoner.ts
-rw-r--r--   1 panda  staff   7544 Sep 10 15:15 figmaMCPAgent.ts
-rw-r--r--   1 panda  staff   1230 Sep  5 16:32 julesAgent.ts
-rw-r--r--   1 panda  staff   1175 Sep  3 15:33 memoryAgent.ts
-rw-r--r--   1 panda  staff   6358 Sep 10 15:16 notionSyncAgent.ts
-rw-r--r--   1 panda  staff  10636 Sep 10 15:13 oradeaBusinessAgent.ts
-rw-r--r--   1 panda  staff    844 Sep  8 14:53 smokeTestAgent.ts
[2025-09-10T15:49:23] tokens used: 3445
[2025-09-10T15:49:28] exec bash -lc "sed -n '1,200p' src/agents/baseAgent.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:28] bash -lc "sed -n '1,200p' src/agents/baseAgent.ts" succeeded in 50ms:
import { AgentResult } from '../orchestrator/types.js';

export interface AgentContext {
  workingDir?: string;
  shared?: Record<string, any>;
}

export interface AgentRunOptions {
  input: string;
  timeoutMs?: number;
  dryRun?: boolean;
}

export abstract class BaseAgent {
  constructor(public id: string, public requirementId: string) {}

  abstract get type(): string;
  abstract run(opts: AgentRunOptions, ctx?: AgentContext): Promise<AgentResult>;

  protected now() { return new Date().toISOString(); }
[2025-09-10T15:49:28] tokens used: 1184
[2025-09-10T15:49:29] exec bash -lc "sed -n '1,240p' src/orchestrator/agentFactory.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:29] bash -lc "sed -n '1,240p' src/orchestrator/agentFactory.ts" succeeded in 64ms:
import { AgentSpec } from './types.js';
import { BaseAgent } from '../agents/baseAgent.js';
import { CodexAgent } from '../agents/codexAgent.js';
import { CodexCLIAgent } from '../agents/codexCLIAgent.js';
import { JulesAgent } from '../agents/julesAgent.js';
import { AbacusAgent } from '../agents/abacusAgent.js';
import { BrowserAgent } from '../agents/browserAgent.js';
import { MemoryAgent } from '../agents/memoryAgent.js';
import { AgentSummonerAgent } from '../agents/agentSummonerAgent.js';
import { AgentSummoner } from '../agents/agentSummoner.js';
import { EnhancedAbacusAgent } from '../agents/enhancedAbacusAgent.js';
import { EUFMAgentSummoner } from '../agents/eufmAgentSummoner.js';
import { SmokeTestAgent } from '../agents/smokeTestAgent.js';
import { TestAgent } from '../agents/testAgent.js';
import { EUFundingProposalAgent } from '../agents/euFundingProposalAgent.js';
import { FigmaMCPAgent } from '../agents/figmaMCPAgent.js';
import { SpecKitCodexAgent } from '../agents/specKitCodexAgent.js';

export class AgentFactory {
  create(spec: AgentSpec): BaseAgent {
[2025-09-10T15:49:29] tokens used: 270
[2025-09-10T15:49:46] exec bash -lc "sed -n '1,260p' src/orchestrator/types.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:46] bash -lc "sed -n '1,260p' src/orchestrator/types.ts" succeeded in 22ms:
export type Capability =
  | 'coding'
  | 'research'
  | 'data'
  | 'web_automation'
  | 'memory'
  | 'file_operations'
  | 'system_access'
  | 'agent_discovery'
  | 'meta_analysis';

export interface TaskRequirement {
  id: string;
  description: string;
  capabilities: Capability[];
  dependencies?: string[];
  priority?: number;
  estimatedComplexity: 'low' | 'medium' | 'high';
  estimatedResources: {
    timeMinutes: number;
[2025-09-10T15:49:46] tokens used: 852
[2025-09-10T15:49:49] exec bash -lc "sed -n '1,260p' src/orchestrator/executionCoordinator.ts" in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:49] bash -lc "sed -n '1,260p' src/orchestrator/executionCoordinator.ts" succeeded in 27ms:
import { AgentSpec, AgentResult, OrchestrationPlan } from './types.js';
import { AgentFactory } from './agentFactory.js';

export interface ExecutionOptions {
  dryRun?: boolean;
  timeoutMs?: number;
  concurrency?: number; // max agents in parallel
}

export class ExecutionCoordinator {
  private factory = new AgentFactory();

  async execute(plan: OrchestrationPlan, inputByReq: Record<string, string>, options: ExecutionOptions = {}): Promise<AgentResult[]> {
    const results: AgentResult[] = [];
    const ctxShared: Record<string, any> = {};
    const concurrency = options.concurrency ?? Math.min(4, plan.parallelBatches.flat().length || 1);

    for (const batch of plan.parallelBatches) {
      // Throttle within batch to configured concurrency
      const queue = [...batch];
[2025-09-10T15:49:49] tokens used: 760

[2025-09-10T15:49:51] thinking

**Considering project setup**

I see that multiple parts of the project are already in place, which is great. The request mentions creating a file structure, installing dependencies, and setting up a TypeScript project. It looks like "agent communication protocols" might be the missing piece. I should consider introducing message protocols, a bus, and message an aggregator while integrating these with existing agents., Plus I need to check the package.json to ensure all dependencies are accounted for.
[2025-09-10T15:49:53] exec bash -lc 'cat package.json' in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:53] bash -lc 'cat package.json' succeeded in 26ms:
{
  "name": "eufm",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc -p .",
    "start": "node dist/cli/index.js",
    "dev": "tsx src/cli/index.ts",
    "lint": "eslint .",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
    "test:country-codes": "tsx src/tests/countryCodes_test.ts",
    "dev:oradea": "tsx src/tools/oradea_business_cli.ts",
    "dev:dashboard": "tsx src/dashboard/dashboardServer.ts"
  },
  "dependencies": {
    "@notionhq/client": "^5.0.0",
    "@types/express": "^5.0.3",
    "@types/ws": "^8.18.1",
[2025-09-10T15:49:53] tokens used: 772
[2025-09-10T15:49:55] exec bash -lc 'cat tsconfig.json' in /Users/panda/Desktop/UBOS
[2025-09-10T15:49:55] bash -lc 'cat tsconfig.json' succeeded in 20ms:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}
[2025-09-10T15:49:55] tokens used: 484

[2025-09-10T15:49:57] thinking

**Planning message protocols**

I need to incorporate agent communication protocols, task delegation, and results aggregation into the project. I think I can implement a message protocol in the src/protocols folder and set up a message bus in src/messaging. I should also add an Aggregator and make sure it integrates with the executionCoordinator. I’ll look for any existing Aggregator first to see how it can fit in. It feels like a solid plan, but I want to make sure I cover everything!
[2025-09-10T15:50:00] exec bash -lc 'rg -n "MessageBus|protocols|Aggregator|aggregation|message protocol|Results aggregation|ResultAggregator|message bus" -S src || true' in /Users/panda/Desktop/UBOS
[2025-09-10T15:50:00] bash -lc 'rg -n "MessageBus|protocols|Aggregator|aggregation|message protocol|Results aggregation|ResultAggregator|message bus" -S src || true' succeeded in 115ms:
src/tools/initializeSystemLogs.ts:16:    'Successfully implemented Master System Registry with agent coordination protocols',
[2025-09-10T15:50:00] tokens used: 298
[2025-09-10T15:50:22] codex

Next, I’ll scaffold the messaging protocol, bus, agent adapters, result aggregation, and a demo script, then wire a package script.
[2025-09-10T15:50:27] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/protocols/messageTypes.ts
import { z } from 'zod';
import type { AgentResult } from '../orchestrator/types.js';

export const MessageHeaderSchema = z.object({
  id: z.string().uuid().optional(),
  type: z.string(),
  source: z.string().optional(),
  timestamp: z.string().datetime().optional(),
  correlationId: z.string().optional(),
});

export type MessageHeader = z.infer<typeof MessageHeaderSchema>;

export const TaskMessageSchema = z.object({
  header: MessageHeaderSchema,
  body: z.object({
    taskId: z.string(),
    requirementId: z.string(),
    input: z.string(),
    params: z.record(z.any()).optional(),
    timeoutMs: z.number().int().positive().optional(),
    dryRun: z.boolean().optional(),
  }),
});

export type TaskMessage = z.infer<typeof TaskMessageSchema>;

export const ResultMessageSchema = z.object({
  header: MessageHeaderSchema,
  body: z.object({
    taskId: z.string(),
    requirementId: z.string(),
    result: z.custom<AgentResult>(),
  }),
});

export type ResultMessage = z.infer<typeof ResultMessageSchema>;

export const BusEventSchema = z.object({
  header: MessageHeaderSchema,
  body: z.object({
    event: z.string(),
    data: z.record(z.any()).optional(),
  }),
});

export type BusEventMessage = z.infer<typeof BusEventSchema>;

export type BusTopic =
  | `task.assign/${string}`
  | `task.assign/agent/${string}`
  | `task.result/${string}`
  | `events/${string}`
  | string;

[2025-09-10T15:50:28] apply_patch(auto_approved=true) exited 0 in 316ms:
Success. Updated the following files:
A src/protocols/messageTypes.ts
[2025-09-10T15:50:28] turn diff:
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:28] tokens used: 1482
[2025-09-10T15:50:28] turn diff:
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:36] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/messaging/messageBus.ts
import { EventEmitter } from 'node:events';
import { randomUUID } from 'node:crypto';
import { z } from 'zod';
import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';

type Handler<T> = (msg: T) => void | Promise<void>;

export class MessageBus {
  private ee = new EventEmitter();

  publish<T extends object>(topic: BusTopic, message: T): void {
    this.ee.emit(topic, message);
  }

  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
    const bound = (msg: T) => handler(msg);
    this.ee.on(topic, bound);
    return () => this.ee.off(topic, bound);
  }

  async request<RequestT extends object, ResponseT extends object>(
    topic: BusTopic,
    request: RequestT,
    opts: { timeoutMs?: number } = {}
  ): Promise<ResponseT> {
    const correlationId = randomUUID();
    const replyTopic = `__reply/${correlationId}`;

    const timeoutMs = opts.timeoutMs ?? 15000;
    return await new Promise<ResponseT>((resolve, reject) => {
      const cleanup = () => {
        clearTimeout(timer);
        this.ee.off(replyTopic, onReply);
      };

      const onReply = (msg: ResponseT) => {
        cleanup();
        resolve(msg);
      };

      const timer = setTimeout(() => {
        cleanup();
        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
      }, timeoutMs);

      this.ee.on(replyTopic, onReply);

      const header = { correlationId };
      const payload = Object.assign({}, request, { header });
      this.publish(topic, payload as any);
    });
  }

  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
    if (!correlationId) return;
    const topic = `__reply/${correlationId}`;
    this.publish(topic, response);
  }

  // Helpers validating standard EUFM messages
  publishTask(topic: BusTopic, msg: TaskMessage): void {
    TaskMessageSchema.parse(msg);
    this.publish(topic, msg);
  }

  publishResult(topic: BusTopic, msg: ResultMessage): void {
    ResultMessageSchema.parse(msg);
    this.publish(topic, msg);
  }

  isHeader(obj: unknown): obj is { header?: unknown } {
    if (!obj || typeof obj !== 'object') return false;
    const maybe = obj as any;
    if (!maybe.header) return false;
    try {
      MessageHeaderSchema.parse(maybe.header);
      return true;
    } catch {
      return false;
    }
  }
}

[2025-09-10T15:50:37] apply_patch(auto_approved=true) exited 0 in 185ms:
Success. Updated the following files:
A src/messaging/messageBus.ts
[2025-09-10T15:50:37] turn diff:
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:37] tokens used: 1476
[2025-09-10T15:50:37] turn diff:
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

    this.unsubscribes = [];
  }
}

[2025-09-10T15:50:45] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/messaging/agentAdapter.ts
import type { BaseAgent } from '../agents/baseAgent.js';
import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
import { MessageBus } from './messageBus.js';

export class AgentAdapter {
  private unsubscribes: Array<() => void> = [];

  constructor(private readonly bus: MessageBus) {}

  register(agent: BaseAgent, spec: AgentSpec) {
    const topics = [
      `task.assign/${spec.requirementId}`,
      `task.assign/agent/${spec.id}`,
    ];

    const handler = async (msg: any) => {
      // Expect TaskMessage shape
      const header: MessageHeader | undefined = msg?.header;
      const body = msg?.body ?? {};
      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
      if (!taskId || !requirementId || typeof input !== 'string') return;

      let result: AgentResult;
      try {
        result = await agent.run(
          { input, timeoutMs, dryRun },
          { shared: params || {} }
        );
      } catch (err: any) {
        result = {
          agentId: agent.id,
          requirementId,
          success: false,
          output: '',
          error: err?.message || 'Unknown error',
          startedAt: new Date().toISOString(),
          finishedAt: new Date().toISOString(),
        };
      }

      const resMsg: ResultMessage = {
        header: {
          type: 'task.result',
          source: agent.type,
          timestamp: new Date().toISOString(),
          correlationId: header?.correlationId,
        },
        body: { taskId, requirementId, result },
      };

      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
      // Also reply if correlation requested
      this.bus.reply(header?.correlationId, resMsg);
    };

    topics.forEach((t) => {
      const unsub = this.bus.subscribe(t, handler);
      this.unsubscribes.push(unsub);
    });
  }

  dispose() {
    this.unsubscribes.forEach((u) => u());
[2025-09-10T15:50:45] apply_patch(auto_approved=true) exited 0 in 130ms:
Success. Updated the following files:
A src/messaging/agentAdapter.ts
[2025-09-10T15:50:45] turn diff:
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:45] tokens used: 1556
[2025-09-10T15:50:45] turn diff:
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:53] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/aggregation/resultAggregator.ts
import type { AgentResult } from '../orchestrator/types.js';

export class ResultAggregator {
  private results: AgentResult[] = [];

  add(result: AgentResult) {
    this.results.push(result);
  }

  getAll(): AgentResult[] {
    return [...this.results];
  }

  success(): boolean {
    return this.results.length > 0 && this.results.every((r) => r.success);
  }

  summary(): string {
    if (this.results.length === 0) return 'No results.';
    const ok = this.results.filter((r) => r.success).length;
    const fail = this.results.length - ok;
    const lines = [
      `Results: ${ok} success, ${fail} failure(s).`,
      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
    ];
    return lines.join('\n');
  }
}

function truncate(s: string, n: number): string {
  return s.length > n ? s.slice(0, n - 1) + '…' : s;
}

[2025-09-10T15:50:54] apply_patch(auto_approved=true) exited 0 in 399ms:
Success. Updated the following files:
A src/aggregation/resultAggregator.ts
[2025-09-10T15:50:54] turn diff:
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:50:54] tokens used: 1193
[2025-09-10T15:50:54] turn diff:
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:51:03] apply_patch auto_approved=true:
A /Users/panda/Desktop/UBOS/src/cli/demo_eufm_agents.ts
import { randomUUID } from 'node:crypto';
import { AgentFactory } from '../orchestrator/agentFactory.js';
import type { AgentSpec } from '../orchestrator/types.js';
import { MessageBus } from '../messaging/messageBus.js';
import { AgentAdapter } from '../messaging/agentAdapter.js';
import { ResultAggregator } from '../aggregation/resultAggregator.js';

async function main() {
  const bus = new MessageBus();
  const factory = new AgentFactory();
  const aggregator = new ResultAggregator();
  const adapter = new AgentAdapter(bus);

  // Minimal demo specs using existing agents in repo
  const specs: AgentSpec[] = [
    {
      id: 'agent:smoke:1',
      type: 'SmokeTestAgent',
      requirementId: 'req:hello',
      capabilities: ['meta_analysis'],
    },
    {
      id: 'agent:memory:1',
      type: 'MemoryAgent',
      requirementId: 'req:memory',
      capabilities: ['memory'],
    },
  ];

  // Create and register agents on the bus
  for (const spec of specs) {
    const agent = factory.create(spec);
    adapter.register(agent, spec);
  }

  // Subscribe to all result topics and aggregate
  specs.forEach((s) => {
    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
      const result = msg?.body?.result;
      if (result) aggregator.add(result);
      // eslint-disable-next-line no-console
      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
    });
  });

  // Send tasks via bus and await replies (request/response)
  const taskId = randomUUID();
  // 1) Hello smoke test
  const res1: any = await bus.request(
    `task.assign/${specs[0].requirementId}`,
    {
      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
    },
    { timeoutMs: 10000 }
  );

  // 2) Memory agent simple prompt
  const res2: any = await bus.request(
    `task.assign/${specs[1].requirementId}`,
    {
      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
    },
    { timeoutMs: 10000 }
  );

  // Aggregate and print summary
  if (res1?.body?.result) aggregator.add(res1.body.result);
  if (res2?.body?.result) aggregator.add(res2.body.result);

  // eslint-disable-next-line no-console
  console.log('\n=== EUFM Demo Aggregated Summary ===');
  // eslint-disable-next-line no-console
  console.log(aggregator.summary());
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error('Demo failed:', err);
  process.exit(1);
});

[2025-09-10T15:51:04] apply_patch(auto_approved=true) exited 0 in 483ms:
Success. Updated the following files:
A src/cli/demo_eufm_agents.ts
[2025-09-10T15:51:04] turn diff:
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:51:04] tokens used: 1390
[2025-09-10T15:51:04] turn diff:
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:51:09] apply_patch auto_approved=true:
M /Users/panda/Desktop/UBOS/package.json
@@ -9,2 +9,3 @@
     "dev": "tsx src/cli/index.ts",
+    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
     "lint": "eslint .",
[2025-09-10T15:51:10] apply_patch(auto_approved=true) exited 0 in 694ms:
Success. Updated the following files:
M package.json
[2025-09-10T15:51:10] turn diff:
diff --git a/package.json b/package.json
index ce621c33f36e904d3477e62ade5b67940b25f4e7..dece4a7cd7f802a9fb882807f6fe55a355993492
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "build": "tsc -p .",
     "start": "node dist/cli/index.js",
     "dev": "tsx src/cli/index.ts",
+    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
     "lint": "eslint .",
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:51:10] tokens used: 1251
[2025-09-10T15:51:10] turn diff:
diff --git a/package.json b/package.json
index ce621c33f36e904d3477e62ade5b67940b25f4e7..dece4a7cd7f802a9fb882807f6fe55a355993492
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "build": "tsc -p .",
     "start": "node dist/cli/index.js",
     "dev": "tsx src/cli/index.ts",
+    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
     "lint": "eslint .",
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+


[2025-09-10T15:51:12] thinking

**Validating files and scripts**

I see that we've added some files. My next step should be to run a type check along with a demo to make sure everything is working properly. But first, need to send a brief I preamble before running any commands. The plan here is to execute the tsx script, ensuring that we have all the necessary groundwork laid out first. This way, we can catch any potential issues early on!
[2025-09-10T15:51:13] codex

I’ll run typecheck and the demo script to flow validate the new messaging and aggregation.
[2025-09-10T15:51:14] exec bash -lc 'npm run typecheck && npm run dev:demo' in /Users/panda/Desktop/UBOS
[2025-09-10T15:51:28] bash -lc 'npm run typecheck && npm run dev:demo' succeeded in 14.04s:

> eufm@0.1.0 typecheck
> tsc -p tsconfig.json --noEmit


> eufm@0.1.0 dev:demo
> tsx src/cli/demo_eufm_agents.ts

[result] req:hello: OK
[result] req:memory: OK

=== EUFM Demo Aggregated Summary ===
Results: 4 success, 0 failure(s).
- [OK] agent:smoke:1/req:hello: SmokeTestAgent OK: Say hello from EUFM demo.
- [OK] agent:memory:1/req:memory: No direct matches in knowledge base.
- [OK] agent:smoke:1/req:hello: SmokeTestAgent OK: Say hello from EUFM demo.
- [OK] agent:memory:1/req:memory: No direct matches in knowledge base.
[2025-09-10T15:51:28] tokens used: 329
[2025-09-10T15:51:28] turn diff:
diff --git a/package.json b/package.json
index ce621c33f36e904d3477e62ade5b67940b25f4e7..dece4a7cd7f802a9fb882807f6fe55a355993492
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "build": "tsc -p .",
     "start": "node dist/cli/index.js",
     "dev": "tsx src/cli/index.ts",
+    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
     "lint": "eslint .",
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+

[2025-09-10T15:51:35] codex

**What I Added**

- Messaging protocol: `src/protocols/messageTypes.ts` with zod-validated headers, task, result, and event schemas.
- Message bus: `src/messaging/messageBus.ts` with publish/subscribe and/re requestply (correlationId) support.
- Agent adapter: `src/messaging/agentAdapter.ts` to bridge existing `BaseAgent.run` into bus message handling.
- Results aggregation: `src/aggregation/resultAggregator.ts` to collect `AgentResult` items produce and a summary.
- Demo runner: `src/cli/demo_eufm_agents.ts` wiring `MessageBus`, `AgentFactory`, the adapter, delegating two tasks, and aggregating results.
- Scripts: Added `dev:demo` to `package.json`.

**How It Works**

- Agents follow existing `BaseAgent` pattern and are instantiated via `AgentFactory`.
- `AgentAdapter` registers each agent to topics:
  - `task.assign/{requirementId}`
  - `task.assign/agent/{agentId}`
- Coordinator (demo) publishes `TaskMessage` to the bus; agents run and publish `ResultMessage` on `task.result/{requirementId}` and also reply via correlationId.
- `Result`Aggregator accumulates results and produces a success/failure summary.

**Run It**

- Typecheck: `npm run typecheck`
- Demo: `npm run dev:demo`

You should see:
- Individual result logs per requirement.
- Aggregated summary at the end.

**Safety & Compatibility**

- Preserves existing code and behavior; no changes to current agents or orchestrator logic.
- Uses existing dependencies (`zod`, Node’s `events`/`crypto`).
- Validated via typecheck and execution of the demo.

**Next Options**

- Want me to integrate the MessageBus into `ExecutionCoordinator` so orchestration plans can delegate over the bus?
- Add result de-duplication or richer summaries (cost, durations)?
- Add logging integration (e.g., pino) across bus and adapter for richer observability?
[2025-09-10T15:51:41] tokens used: 890
[2025-09-10T15:51:41] turn diff:
diff --git a/package.json b/package.json
index ce621c33f36e904d3477e62ade5b67940b25f4e7..dece4a7cd7f802a9fb882807f6fe55a355993492
--- a/package.json
+++ b/package.json
@@ -7,6 +7,7 @@
     "build": "tsc -p .",
     "start": "node dist/cli/index.js",
     "dev": "tsx src/cli/index.ts",
+    "dev:demo": "tsx src/cli/demo_eufm_agents.ts",
     "lint": "eslint .",
     "typecheck": "tsc -p tsconfig.json --noEmit",
     "test:integration": "tsx src/tests/eufm_integration_test.ts 'Integration check'",
diff --git a/src/aggregation/resultAggregator.ts b/src/aggregation/resultAggregator.ts
new file mode 100644
index 0000000000000000000000000000000000000000..760a2719a716cfaa577188dbf27d63ea8a4a4bc1
--- /dev/null
+++ b/src/aggregation/resultAggregator.ts
@@ -0,0 +1,33 @@
+import type { AgentResult } from '../orchestrator/types.js';
+
+export class ResultAggregator {
+  private results: AgentResult[] = [];
+
+  add(result: AgentResult) {
+    this.results.push(result);
+  }
+
+  getAll(): AgentResult[] {
+    return [...this.results];
+  }
+
+  success(): boolean {
+    return this.results.length > 0 && this.results.every((r) => r.success);
+  }
+
+  summary(): string {
+    if (this.results.length === 0) return 'No results.';
+    const ok = this.results.filter((r) => r.success).length;
+    const fail = this.results.length - ok;
+    const lines = [
+      `Results: ${ok} success, ${fail} failure(s).`,
+      ...this.results.map((r) => `- [${r.success ? 'OK' : 'ERR'}] ${r.agentId}/${r.requirementId}: ${truncate(r.output || r.error || '', 140)}`),
+    ];
+    return lines.join('\n');
+  }
+}
+
+function truncate(s: string, n: number): string {
+  return s.length > n ? s.slice(0, n - 1) + '…' : s;
+}
+
diff --git a/src/cli/demo_eufm_agents.ts b/src/cli/demo_eufm_agents.ts
new file mode 100644
index 0000000000000000000000000000000000000000..58d35a4e60be471360b052f0d4c43c5966832227
--- /dev/null
+++ b/src/cli/demo_eufm_agents.ts
@@ -0,0 +1,83 @@
+import { randomUUID } from 'node:crypto';
+import { AgentFactory } from '../orchestrator/agentFactory.js';
+import type { AgentSpec } from '../orchestrator/types.js';
+import { MessageBus } from '../messaging/messageBus.js';
+import { AgentAdapter } from '../messaging/agentAdapter.js';
+import { ResultAggregator } from '../aggregation/resultAggregator.js';
+
+async function main() {
+  const bus = new MessageBus();
+  const factory = new AgentFactory();
+  const aggregator = new ResultAggregator();
+  const adapter = new AgentAdapter(bus);
+
+  // Minimal demo specs using existing agents in repo
+  const specs: AgentSpec[] = [
+    {
+      id: 'agent:smoke:1',
+      type: 'SmokeTestAgent',
+      requirementId: 'req:hello',
+      capabilities: ['meta_analysis'],
+    },
+    {
+      id: 'agent:memory:1',
+      type: 'MemoryAgent',
+      requirementId: 'req:memory',
+      capabilities: ['memory'],
+    },
+  ];
+
+  // Create and register agents on the bus
+  for (const spec of specs) {
+    const agent = factory.create(spec);
+    adapter.register(agent, spec);
+  }
+
+  // Subscribe to all result topics and aggregate
+  specs.forEach((s) => {
+    bus.subscribe(`task.result/${s.requirementId}`, (msg: any) => {
+      const result = msg?.body?.result;
+      if (result) aggregator.add(result);
+      // eslint-disable-next-line no-console
+      console.log(`[result] ${s.requirementId}: ${result?.success ? 'OK' : 'ERR'}`);
+    });
+  });
+
+  // Send tasks via bus and await replies (request/response)
+  const taskId = randomUUID();
+  // 1) Hello smoke test
+  const res1: any = await bus.request(
+    `task.assign/${specs[0].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[0].requirementId, input: 'Say hello from EUFM demo.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // 2) Memory agent simple prompt
+  const res2: any = await bus.request(
+    `task.assign/${specs[1].requirementId}`,
+    {
+      header: { type: 'task.assign', source: 'demo', timestamp: new Date().toISOString() },
+      body: { taskId, requirementId: specs[1].requirementId, input: 'Store a note: EUFM demo completed.' },
+    },
+    { timeoutMs: 10000 }
+  );
+
+  // Aggregate and print summary
+  if (res1?.body?.result) aggregator.add(res1.body.result);
+  if (res2?.body?.result) aggregator.add(res2.body.result);
+
+  // eslint-disable-next-line no-console
+  console.log('\n=== EUFM Demo Aggregated Summary ===');
+  // eslint-disable-next-line no-console
+  console.log(aggregator.summary());
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error('Demo failed:', err);
+  process.exit(1);
+});
+
diff --git a/src/messaging/agentAdapter.ts b/src/messaging/agentAdapter.ts
new file mode 100644
index 0000000000000000000000000000000000000000..783ddbd046003e8c6331d5849675fe832dfef075
--- /dev/null
+++ b/src/messaging/agentAdapter.ts
@@ -0,0 +1,68 @@
+import type { BaseAgent } from '../agents/baseAgent.js';
+import type { AgentSpec, AgentResult } from '../orchestrator/types.js';
+import type { MessageHeader, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { MessageBus } from './messageBus.js';
+
+export class AgentAdapter {
+  private unsubscribes: Array<() => void> = [];
+
+  constructor(private readonly bus: MessageBus) {}
+
+  register(agent: BaseAgent, spec: AgentSpec) {
+    const topics = [
+      `task.assign/${spec.requirementId}`,
+      `task.assign/agent/${spec.id}`,
+    ];
+
+    const handler = async (msg: any) => {
+      // Expect TaskMessage shape
+      const header: MessageHeader | undefined = msg?.header;
+      const body = msg?.body ?? {};
+      const { taskId, requirementId, input, params, timeoutMs, dryRun } = body;
+      if (!taskId || !requirementId || typeof input !== 'string') return;
+
+      let result: AgentResult;
+      try {
+        result = await agent.run(
+          { input, timeoutMs, dryRun },
+          { shared: params || {} }
+        );
+      } catch (err: any) {
+        result = {
+          agentId: agent.id,
+          requirementId,
+          success: false,
+          output: '',
+          error: err?.message || 'Unknown error',
+          startedAt: new Date().toISOString(),
+          finishedAt: new Date().toISOString(),
+        };
+      }
+
+      const resMsg: ResultMessage = {
+        header: {
+          type: 'task.result',
+          source: agent.type,
+          timestamp: new Date().toISOString(),
+          correlationId: header?.correlationId,
+        },
+        body: { taskId, requirementId, result },
+      };
+
+      this.bus.publishResult(`task.result/${requirementId}`, resMsg);
+      // Also reply if correlation requested
+      this.bus.reply(header?.correlationId, resMsg);
+    };
+
+    topics.forEach((t) => {
+      const unsub = this.bus.subscribe(t, handler);
+      this.unsubscribes.push(unsub);
+    });
+  }
+
+  dispose() {
+    this.unsubscribes.forEach((u) => u());
+    this.unsubscribes = [];
+  }
+}
+
diff --git a/src/messaging/messageBus.ts b/src/messaging/messageBus.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4b1e3880bb52053cd4d9aff69adc39118629636
--- /dev/null
+++ b/src/messaging/messageBus.ts
@@ -0,0 +1,84 @@
+import { EventEmitter } from 'node:events';
+import { randomUUID } from 'node:crypto';
+import { z } from 'zod';
+import type { BusTopic, TaskMessage, ResultMessage } from '../protocols/messageTypes.js';
+import { TaskMessageSchema, ResultMessageSchema, MessageHeaderSchema } from '../protocols/messageTypes.js';
+
+type Handler<T> = (msg: T) => void | Promise<void>;
+
+export class MessageBus {
+  private ee = new EventEmitter();
+
+  publish<T extends object>(topic: BusTopic, message: T): void {
+    this.ee.emit(topic, message);
+  }
+
+  subscribe<T extends object>(topic: BusTopic, handler: Handler<T>): () => void {
+    const bound = (msg: T) => handler(msg);
+    this.ee.on(topic, bound);
+    return () => this.ee.off(topic, bound);
+  }
+
+  async request<RequestT extends object, ResponseT extends object>(
+    topic: BusTopic,
+    request: RequestT,
+    opts: { timeoutMs?: number } = {}
+  ): Promise<ResponseT> {
+    const correlationId = randomUUID();
+    const replyTopic = `__reply/${correlationId}`;
+
+    const timeoutMs = opts.timeoutMs ?? 15000;
+    return await new Promise<ResponseT>((resolve, reject) => {
+      const cleanup = () => {
+        clearTimeout(timer);
+        this.ee.off(replyTopic, onReply);
+      };
+
+      const onReply = (msg: ResponseT) => {
+        cleanup();
+        resolve(msg);
+      };
+
+      const timer = setTimeout(() => {
+        cleanup();
+        reject(new Error(`MessageBus request timeout after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      this.ee.on(replyTopic, onReply);
+
+      const header = { correlationId };
+      const payload = Object.assign({}, request, { header });
+      this.publish(topic, payload as any);
+    });
+  }
+
+  reply<ResponseT extends object>(correlationId: string | undefined, response: ResponseT): void {
+    if (!correlationId) return;
+    const topic = `__reply/${correlationId}`;
+    this.publish(topic, response);
+  }
+
+  // Helpers validating standard EUFM messages
+  publishTask(topic: BusTopic, msg: TaskMessage): void {
+    TaskMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  publishResult(topic: BusTopic, msg: ResultMessage): void {
+    ResultMessageSchema.parse(msg);
+    this.publish(topic, msg);
+  }
+
+  isHeader(obj: unknown): obj is { header?: unknown } {
+    if (!obj || typeof obj !== 'object') return false;
+    const maybe = obj as any;
+    if (!maybe.header) return false;
+    try {
+      MessageHeaderSchema.parse(maybe.header);
+      return true;
+    } catch {
+      return false;
+    }
+  }
+}
+
diff --git a/src/protocols/messageTypes.ts b/src/protocols/messageTypes.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1b5485e4ab802d22360d65b19e78391aca78705c
--- /dev/null
+++ b/src/protocols/messageTypes.ts
@@ -0,0 +1,55 @@
+import { z } from 'zod';
+import type { AgentResult } from '../orchestrator/types.js';
+
+export const MessageHeaderSchema = z.object({
+  id: z.string().uuid().optional(),
+  type: z.string(),
+  source: z.string().optional(),
+  timestamp: z.string().datetime().optional(),
+  correlationId: z.string().optional(),
+});
+
+export type MessageHeader = z.infer<typeof MessageHeaderSchema>;
+
+export const TaskMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    input: z.string(),
+    params: z.record(z.any()).optional(),
+    timeoutMs: z.number().int().positive().optional(),
+    dryRun: z.boolean().optional(),
+  }),
+});
+
+export type TaskMessage = z.infer<typeof TaskMessageSchema>;
+
+export const ResultMessageSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    taskId: z.string(),
+    requirementId: z.string(),
+    result: z.custom<AgentResult>(),
+  }),
+});
+
+export type ResultMessage = z.infer<typeof ResultMessageSchema>;
+
+export const BusEventSchema = z.object({
+  header: MessageHeaderSchema,
+  body: z.object({
+    event: z.string(),
+    data: z.record(z.any()).optional(),
+  }),
+});
+
+export type BusEventMessage = z.infer<typeof BusEventSchema>;
+
+export type BusTopic =
+  | `task.assign/${string}`
+  | `task.assign/agent/${string}`
+  | `task.result/${string}`
+  | `events/${string}`
+  | string;
+


Process exited with code: 0
